---
title: "here"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{here}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  error = !identical(Sys.getenv("IN_PKGDOWN"), "true")
)

project_path <- system.file("demo-project", package = "here")

knitr::opts_knit$set(root.dir = project_path)
```

The here package enables easy file referencing by using the top-level directory of a file project to easily build file paths.
This is in contrast to using `setwd()`, which is fragile and dependent on the way you order your files on your computer.
Read more about project-oriented workflows:

- What They Forgot to Teach You About R: ["Project-oriented workflow"](https://rstats.wtf/project-oriented-workflow.html) chapter by Jenny Bryan and Jim Hester

- ["Project-oriented workflow"](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/) blog post by Jenny Bryan

- R for data science: ["Workflow: projects"](https://r4ds.had.co.nz/workflow-projects.html) chapter by Hadley Wickham

## Basic functionality

For demonstration, this article uses a data analysis project that lives in `` `r project_path` `` on my machine.
This is the *project root*.
The path will most likely be different on your machine, the here package helps deal with this situation.

The project has the following structure:

```{r echo = FALSE}
fs::dir_tree()
```

To start working on this project in RStudio, open the `demo-project.Rproj` file.
This ensures that the [working directory](https://en.wikipedia.org/wiki/Working_directory) is set to `` `r project_path` ``, the project root.
Opening only the `.R` or the `.Rmd` file may be insufficient!

Other development environments may have a different notion of a project.
Either way, it is important that the working directory is set to the project root or a subdirectory of that path.
You can check with:

```{r eval = FALSE}
setwd(project_path)
```

```{r}
getwd()
```

(See `vignette("rmarkdown")` for an example where the working directory is set to a subdirectory on start.)

The package displays the top-level directory of the current project when the package is loaded:[^attached]

[^attached]: Technically, `library()` loads and attaches a package. The message is printed only when the package is attached; if your code only uses `here::here()`, no message is printed.

```{r}
library(here)
```

In our case, the `demo-project.Rproj` file decides what the project root is.

The top-level directory is also returned from the `here()` function:

```{r}
here()
```

One important distinction from the working directory is that this remains stable even if the working directory is changed:

```{r}
setwd("analysis")
getwd()
here()
setwd("..")
```

(I suggest to steer clear from ever changing the working directory.
This may not always be feasible, in particular if the working directory is changed by code that you do not control.)


## Relative paths

You can build a path relative to the top-level directory in order to build the full path to a file:

```{r}
here("data", "penguins.csv")
readr::read_csv(here("data", "penguins.csv"))
```

This works regardless of where the associated source file lives inside your project.
With `here()`, the path will always be relative to the top-level project directory.

`here()` works very similarly to `file.path()` or `fs::path()`, you can pass path components or entire subpaths:

```{r}
here("data/penguins.csv")
```

As seen above, `here()` returns absolute paths (starting with `/`, `<drive letter>:\` or `\\`).
This makes it safe to pass these paths to other functions, even if the working directory is changed along the way.

As of version 1.0.0, absolute paths passed to `here()` are returned unchanged.
This means that you can safely use both absolute and project-relative paths in `here()`.

```{r}
data_path <- here("data")
here(data_path)
here(data_path, "penguins.csv")
```


## Situation report

The `dr_here()` function explains the reasoning behind choosing the project root:

```{r}
dr_here()
```

The `show_reason` argument can be set to `FALSE` to reduce the output to one line:

```{r}
dr_here(show_reason = FALSE)
```


## Define project root

The `here()` function supports a variety of common project formats, see `?here` for details.
If no project is found, the working directory is used as fallback.
The heuristics can be overridden by creating a `.here` file, the `set_here()` function takes care of that.

To start, let's create a temporary project for demonstration:

```{r}
temp_project_path <- tempfile()
dir.create(temp_project_path)
dir.create(file.path(temp_project_path, "scripts"))
writeLines('print("Hello, world!")', file.path(temp_project_path, "scripts", "script.R"))
fs::dir_tree(temp_project_path)
```

When starting in the `scripts` directory, the here package will not find any project.
Use `set_here()` to define the project root:

```{r}
set_here(temp_project_path)
fs::dir_tree(temp_project_path, all = TRUE)
```

Note the message about restarting the R session.
This is because the here package never changes its notion of a project root once loaded.
This is by design.
The next sections show possible remedies.

## Change project root

Once the here package is loaded, subsequential attempts to load do not change here's notion of the project root.
No message is printed, and the `here()` output is unchanged:

```{r}
library(here)
setwd(temp_project_path)
library(here)
setwd(project_path)
here()
```

This is by design:

- it keeps the interface as simple as possible
- it gently nudges you to [start a fresh R session](https://rstats.wtf/save-source.html) when focusing on another project

Nevertheless, there may be cases when it is desirable to reset here's notion of the project root.
This can be achieved with unloading and reloading the package:

```{r}
unloadNamespace("here")
setwd(temp_project_path)
library(here)
setwd(project_path)
getwd()
here()
```

To reiterate: a fresh session is almost always the better, cleaner, safer, and more robust solution.
Use this approach only as a last resort.


## Under the hood: rprojroot

The here package has a very simple and restricted interface, by design.
The logic is driven by the rprojroot package.
To find an RStudio project starting from a directory, use:

```{r}
library(rprojroot)
find_root(is_rstudio_project, file.path(project_path, "analysis"))
```

See `vignette("rprojroot", package = "rprojroot")` for an introduction.
